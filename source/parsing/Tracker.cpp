//--------------------------------------------------------------------------------
// (C) Copyright 2014-2015 Stephane Molina, All rights reserved.
// See https://github.com/Dllieu for updates, documentation, and revision history.
//--------------------------------------------------------------------------------
#include <iostream>

#include "utility/Sha1Encoder.h"
#include "utility/RandomGenerator.h"
#include "RootMetaInfo.h"
#include "Tracker.h"

using namespace parsing;

Tracker::Tracker( RootMetaInfo&& root )
    : root_( root )
    , peerId_( "-DL0101-zzzzz" ) // Todo: global by torrent client app (should not be unique by tracker)
{
    // NOTHING
}

void    Tracker::scrape()
{
    // send / receive require non const endpoint
    std::vector< bai::udp::endpoint > endpoints = root_.getAnnouncers();
    for ( auto& endpoint : endpoints )
    {
        // TEST PHASE : just use an endpoint who respond
        if ( endpoint.address().to_string() != "185.37.101.229" ) // hehe
            continue;

        bai::udp::socket     socket( ioService_ );

        socket.open( bai::udp::v4() );
        socket.connect( endpoint );

        buffer_.clear();

        // 1 - CONNECT
        // Offset  Size            Name            Value
        //     0       64 - bit integer  connection_id   0x41727101980
        //     8       32 - bit integer  action          0 // connect
        //     12      32 - bit integer  transaction_id
        //     16
        connectionId_ = 0x41727101980;
        auto action = 0; // connect
        transactionId_ = utility::RandomGenerator< int >::instance().generate();

        buffer_ << connectionId_ << action << transactionId_;
        socket.send_to( boost::asio::buffer( buffer_.getDataForReading(), buffer_.size() ), endpoint );
        // 1 - ******

        // 2 - CONNECT ANSWER WITH PROPER CONNECTION_ID
        // Offset  Size            Name            Value
        //     0       32 - bit integer  action          0 // connect
        //     4       32 - bit integer  transaction_id
        //     8       64 - bit integer  connection_id
        //     16
        buffer_.updateDataWritten( socket.receive_from( boost::asio::buffer( buffer_.getDataForWriting(), 16 ), endpoint ) ); // getDataForWriting do an implicit clear()

        int receivedTransactionId = 0;
        buffer_ >> action >> receivedTransactionId >> connectionId_;
        std::cout << "received connection id: " << action << "|" << transactionId_ << "|" << connectionId_ << std::endl;
        buffer_.clear();
        // 2 - ******

        // 3 - SEND ANNOUNCE REQUEST
        // Offset  Size    Name    Value
        //  0       64 - bit integer  connection_id
        //  8       32 - bit integer  action          1 // announce
        //  12      32 - bit integer  transaction_id
        //  16      20 - byte string  info_hash
        //  36      20 - byte string  peer_id
        //  56      64 - bit integer  downloaded
        //  64      64 - bit integer  left
        //  72      64 - bit integer  uploaded
        //  80      32 - bit integer  event           0 // 0: none; 1: completed; 2: started; 3: stopped
        //  84      32 - bit integer  IP address      0 // IP address set to 0. Response received to the sender of this packet
        //  88      32 - bit integer  key
        //  92      32 - bit integer  num_want - 1 // default
        //  96      16 - bit integer  port

        action = 1;
        buffer_ << connectionId_ << action << transactionId_;

        std::cout << "Send Announce request with SHA1: " << utility::sha1_to_string( root_.getHashInfo() ) << std::endl;

        buffer_.writeArray( root_.getHashInfo() );
        // urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup. This is allowed to be any value, and may be binary data.
        // There are currently no guidelines for generating this peer ID. However, one may rightly presume that it must at least be unique for your local machine,
        // thus should probably incorporate things like process ID and perhaps a timestamp recorded at startup. See peer_id below for common client encodings of this field.
        buffer_.writeString( peerId_, 20 );

        uint64_t downloaded = 0;
        uint64_t left = root_.getBytesToDownload();
        uint64_t uploaded = 0;
        int evnt = 2; // start downloading
        int ipAddress = 0;
        auto key = utility::RandomGenerator< int >::instance().generate(); // randomized by client / unique by lan
        int num_want = -1;
        short port = socket.remote_endpoint().port();

        buffer_ << downloaded << left << uploaded << evnt << ipAddress << key << num_want << port;
        socket.send_to( boost::asio::buffer( buffer_.getDataForReading(), buffer_.size() ), endpoint );
        // 3 - ******

        // 4 - RECEIVE ANNOUNCE RESPONSE
        // Offset      Size            Name            Value
        //  0           32 - bit integer  action          1 // announce
        //  4           32 - bit integer  transaction_id
        //  8           32 - bit integer  interval
        //  12          32 - bit integer  leechers
        //  16          32 - bit integer  seeders
        //  20 + 6 * n  32 - bit integer  IP address
        //  24 + 6 * n  16 - bit integer  TCP port
        //  20 + 6 * N
        // (Can go up to 74 torents)
        buffer_.updateDataWritten( socket.receive_from( boost::asio::buffer( buffer_.getDataForWriting(), buffer_.capacity() ), endpoint ) );
        if ( buffer_.size() < 160 )
            throw std::invalid_argument( "Announce answer is less than 160 bytes" );
        std::cout << "!!!! " << buffer_.size() << std::endl;

        int interval = 0; // in seconds
        int leechers = 0;
        int seeders = 0;
        buffer_ >> action >> receivedTransactionId >> interval >> leechers >> seeders;

        std::cout << "leechers: " << leechers << " | seeders: " << seeders << std::endl;
        // 4 - ******
    }
}
