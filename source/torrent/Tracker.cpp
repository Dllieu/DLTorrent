//--------------------------------------------------------------------------------
// (C) Copyright 2014-2015 Stephane Molina, All rights reserved.
// See https://github.com/Dllieu for updates, documentation, and revision history.
//--------------------------------------------------------------------------------

#include "Tracker.h"

#include <iostream>

#include "utility/Sha1Encoder.h"
#include "utility/RandomGenerator.h"
#include "utility/TypeTraits.h"

#include "Torrent.h"
#include "TrackerSocket.h"

using namespace torrent;
namespace bai = boost::asio::ip;

namespace
{
    enum class TrackerAction : int
    {
        Connect = 0,
        Announce = 1,
        Scrap = 2, // TODO: Not supported ATM
        Error = 3,
    };
}

struct Tracker::PImpl
{
    using BufferType = TrackerSocket::BufferType;

    const std::vector< bai::tcp::endpoint >&    peerEndpoints( const Torrent& torrent )
    {
        auto announcers = torrent.getAnnouncers(); // make copy as send / connect / receive will modify announcer
        for ( auto& announcer : announcers )
        {
            // TEST PHASE : just use an endpoint who respond
            if ( announcer.address().to_string() == "185.37.101.229" )
                continue;

            TrackerSocket socket( announcer );

            // TODO: class a part + cleaning + check error
            if ( ! socket.connect()
                || ! sendAndReceive( socket, torrent, TrackerAction::Connect )
                || ! sendAndReceive( socket, torrent, TrackerAction::Announce ) )
                continue;

            break;
        }
        return peerEndpoints_;
    }

    // Always start by
    // Offset  Size            Name            Value
    //     0       32 - bit integer  action          0 // connect
    //     4       32 - bit integer  transaction_id
    //     8
    bool    sendAndReceive( TrackerSocket& socket, const Torrent& torrent, TrackerAction action ) // return next action to be sent (i.e. next send message is ready)
    {
        auto& buffer = socket.buffer();
        buffer.clear();

        return prepareMessage( action, buffer, socket.port(), torrent )

            && socket.send()
            && socket.receive()

            && buffer.size() >= 8 && static_cast< int >( buffer ) == utility::enum_cast( action ) && static_cast< int >( buffer ) == transactionId_
            && handleReceivedMessage( buffer, action );
    }

    bool    prepareMessage( TrackerAction action, BufferType& buffer, short port, const Torrent& torrent )
    {
        switch ( action )
        {
            case TrackerAction::Connect:
                prepareSendConnect( buffer );
                break;

            case TrackerAction::Announce:
                prepareSendAnnounce( buffer, port, torrent );
                break;

            // TODO: can scrap up to 74 torrent at once
            case TrackerAction::Scrap:
            default:
                return false;
        }

        return true;
    }

    // Offset  Size            Name            Value
    //     0       64 - bit integer  connection_id   0x41727101980
    //     8       32 - bit integer  action          0 // connect
    //     12      32 - bit integer  transaction_id
    //     16
    void    prepareSendConnect( BufferType& buffer )
    {
        buffer << static_cast< uint64_t >( 0x41727101980 ) // UNINITIALIZED_CONNECTION_ID
               << utility::enum_cast( TrackerAction::Connect )
               << ( transactionId_ = utility::RandomGenerator< int >::instance().generate() );
    }

    // Offset  Size    Name    Value
    //  0       64 - bit integer  connection_id
    //  8       32 - bit integer  action          1 // announce
    //  12      32 - bit integer  transaction_id
    //  16      20 - byte string  info_hash
    //  36      20 - byte string  peer_id
    //  56      64 - bit integer  downloaded
    //  64      64 - bit integer  left
    //  72      64 - bit integer  uploaded
    //  80      32 - bit integer  event           0 // 0: none; 1: completed; 2: started; 3: stopped
    //  84      32 - bit integer  IP address      0 // IP address set to 0. Response received to the sender of this packet
    //  88      32 - bit integer  key
    //  92      32 - bit integer  num_want - 1 // default
    //  96      16 - bit integer  port
    void    prepareSendAnnounce( BufferType& buffer, short port, const Torrent& torrent )
    {
        buffer << connectionId_
                << utility::enum_cast( TrackerAction::Announce )
                << transactionId_;

        std::cout << "Send Announce request with SHA1: " << utility::sha1_to_string( torrent.getHashInfo() ) << std::endl;

        buffer.writeArray( torrent.getHashInfo() );
        // urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup. This is allowed to be any value, and may be binary data.
        // There are currently no guidelines for generating this peer ID. However, one may rightly presume that it must at least be unique for your local machine,
        // thus should probably incorporate things like process ID and perhaps a timestamp recorded at startup. See peer_id below for common client encodings of this field.
        buffer.writeString( /*peerId_*/"-DL0101-zzzzz", 20 );

        uint64_t downloaded = 0;
        uint64_t left = torrent.getBytesToDownload();
        uint64_t uploaded = 0;
        int evnt = 2; // start downloading
        int ipAddress = 0;
        auto key = utility::RandomGenerator< int >::instance().generate(); // randomized by client / unique by lan
        int num_want = -1;

        buffer << downloaded << left << uploaded << evnt << ipAddress << key << num_want << port;
    }

    bool    handleReceivedMessage( BufferType& buffer, TrackerAction action )
    {
        switch ( action )
        {
            case TrackerAction::Connect:
                return handleConnect( buffer );

            case TrackerAction::Announce:
                return handleAnnounce( buffer );

            case TrackerAction::Error:
                return handleError( buffer );

                // TODO: can scrap up to 74 torrent at once
            case TrackerAction::Scrap:
            default:
                return false;
        }
    }

    // Offset  Size            Name            Value
    //     8       64 - bit integer  connection_id
    //     16
    bool    handleConnect( BufferType& buffer )
    {
        if ( buffer.size() < 8 )
            return false;

        std::cout << "received connect" << std::endl;
        buffer >> connectionId_;
        return true;
    }

    // Offset      Size            Name            Value
    //  8           32 - bit integer  interval
    //  12          32 - bit integer  leechers
    //  16          32 - bit integer  seeders
    //  20 + 6 * n  32 - bit integer  IP address
    //  24 + 6 * n  16 - bit integer  TCP port // + 16 bit for the last one as it might be aligned
    //  20 + 6 * N
    bool    handleAnnounce( BufferType& buffer )
    {
        if ( buffer.size() < 152 )
        {
            std::cout << "Announce answer incorrect size" << std::endl;
            return false;
        }

        std::cout << "!!!! " << buffer.size() << std::endl;

        auto interval = static_cast< int >( buffer ); // in seconds
        auto leechers = static_cast< int >( buffer );
        auto seeders = static_cast< int >( buffer );

        std::cout << "Peers:" << std::endl;

        int ipAddress = 0;
        short port = 0;
        while ( buffer.size() > 48 /*sizeof(ip) + sizeof(port)*/ ) // ???????
        {
            buffer >> ipAddress >> port;

            peerEndpoints_.emplace_back( boost::asio::ip::address_v4( ipAddress ), port );
        }

        // to remove (test)
        //test_stuff( peerEndpoints );

        std::cout << "Peers available: " << peerEndpoints_.size() << std::endl;
        std::cout << "leechers: " << leechers << " | seeders: " << seeders << std::endl;

        return true;
    }

    // Offset  Size            Name            Value
    //     8       string  message
    bool    handleError( BufferType& buffer )
    {
        if ( buffer.size() < 8 )
            return false;

        std::cout << "Received error from Tracker: " << buffer.readString( 8 ) << std::endl;
        return false;
    }

private:
    int                                         transactionId_;
    uint64_t                                    connectionId_;
    std::vector< bai::tcp::endpoint >           peerEndpoints_;
};

Tracker::Tracker()
    : pimpl_( std::make_unique< PImpl >() )
{}

Tracker::~Tracker() = default;

const std::vector< bai::tcp::endpoint >&    Tracker::peerEndpoints( const Torrent& torrent )
{
    return pimpl_->peerEndpoints( torrent );
}
